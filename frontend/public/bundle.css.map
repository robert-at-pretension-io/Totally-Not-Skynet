{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "AuthPage.svelte",
    "GraphComponent_graphlib.svelte",
    "Loading.svelte",
    "Sidebar.svelte",
    "AtomicExecution.svelte",
    "ConditionalComponent.svelte",
    "LoopComponent.svelte",
    "ProcessComponent.svelte",
    "PromptComponent.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import Sidebar from \"./components/Sidebar.svelte\";\nimport GraphComponentGraphlib from \"./components/GraphComponent_graphlib.svelte\";\nimport { setupWebsocketConnection } from \"helper_functions/websocket\";\nimport { onMount } from \"svelte\";\nimport systemStateStore from \"stores/systemStateStore\";\nimport { websocketStore } from \"stores/websocketStore\";\nimport AuthPage from \"./components/AuthPage.svelte\";\nimport \"./generated/system_types\";\nimport Loading from \"./components/Loading.svelte\";\nimport { initializeSystemState } from \"helper_functions/misc\";\nconsole.log(\"Script started\");\nlet websocket;\nlet system_state;\nlet websocket_ready = false;\nlet authenticated;\nlet expanded = false;\nonMount(() => {\n    console.log(\"onMount triggered\");\n    $systemStateStore = initializeSystemState($systemStateStore);\n    system_state = $systemStateStore;\n    console.log(\"Initial system_state:\", system_state);\n    if (!websocket_ready) {\n        console.log(\"Websocket not ready. Initializing...\");\n        websocket = setupWebsocketConnection();\n        console.log(\"Websocket initialized:\", websocket);\n        websocketStore.set({ websocket });\n        websocket_ready = true;\n        $systemStateStore = system_state;\n    }\n});\n$: {\n    console.log(\"auth state\", $systemStateStore.authenticated);\n    authenticated = $systemStateStore.authenticated;\n}\n</script>\n\n{#if !authenticated}\n  {#if websocket_ready}\n    <AuthPage />\n  {:else}\n    <Loading />\n  {/if}\n{/if}\n\n{#if authenticated}\n  <div class=\"app-container\">\n    <Sidebar bind:expanded />\n    <GraphComponentGraphlib />\n  </div>\n{/if}\n\n<style>\n  .app-container {\n    display: flex;\n    height: 100vh; /* 100% of the viewport height */\n  }\n</style>\n",
    "<script>\n  import { websocketStore } from \"stores/websocketStore\";\n  import { authenticate } from \"helper_functions/authentication\";\n  import { Secrets, UserSettings } from \"generated/system_types\";\n\n  let username = \"\";\n  let password = \"\";\n  let api_key = \"\";\n  let displayedApiKey = \"\";\n\n  // Load the API key from localStorage\n  api_key = localStorage.getItem(\"api_key\") || \"\";\n  displayedApiKey = maskApiKey(api_key);\n\n  function maskApiKey(key) {\n    // Show only the first 4 characters and mask the rest\n    return key.substr(0, 4) + key.slice(4).replace(/./g, \"*\");\n  }\n\n  $: displayedApiKey = maskApiKey(api_key);\n\n  function handleApiKeyChange(event) {\n    // Update the actual API key when the user edits the input\n    api_key = event.target.value;\n  }\n\n  function handleSubmit() {\n    console.log(\"Username:\", username);\n    console.log(\"Password:\", password);\n\n    let secret = new Secrets();\n\n    secret.email = username;\n    secret.password = password;\n\n    let user_settings = new UserSettings();\n    user_settings.openai_api_key = api_key;\n\n    localStorage.setItem(\"api_key\", api_key);\n\n    secret.user_settings = user_settings;\n\n    // set authentication to true\n\n    let websocket = $websocketStore.websocket;\n    authenticate(websocket, secret);\n  }\n\n  // Send POST with authentication Message\n</script>\n\n<div class=\"container\">\n  <div class=\"fields\">\n    <input type=\"text\" bind:value={username} placeholder=\"Username\" />\n    <input type=\"password\" bind:value={password} placeholder=\"Password\" />\n    <textarea\n      type=\"text\"\n      value={displayedApiKey}\n      class=\"auto-expand\"\n      on:input={handleApiKeyChange}\n      placeholder=\"API Key\"\n    /> <button class=\"submit-button\" on:click={handleSubmit}>Submit</button>\n  </div>\n</div>\n\n<style>\n  .container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n  }\n  .fields {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n  }\n  .submit-button {\n    background-color: green;\n    color: white;\n    padding: 10px 20px;\n    border: none;\n    cursor: pointer;\n    font-size: 16px;\n    transition: 0.3s;\n  }\n  .submit-button:hover {\n    background-color: darkgreen;\n  }\n\n  .auto-expand {\n    overflow-y: hidden; /* Hide vertical scrollbar */\n    resize: none; /* Disable resizing */\n    min-height: 20px; /* Set a minimum height */\n    max-height: 400px; /* Set a maximum height */\n  }\n</style>\n",
    "<script lang=\"ts\">var _a;\nimport { onMount, setContext } from \"svelte\";\nimport cytoscape from \"cytoscape\";\nimport systemStateStore from \"stores/systemStateStore.js\";\nimport * as helper_functions from \"../helper_functions/graph\";\nimport * as proto from \"../generated/system_types\";\nimport dagre from \"cytoscape-dagre\";\n// import { Node } from \"generated/system_types_pb\";\n// import { generateDynamicStyles } from \"../helper_functions/graph\";\nimport \"../generated/system_types\";\nlet current_graph = new proto.Graph();\nonMount(() => {\n    console.log(\"Graph Component Mounted\");\n    cytoscape.use(dagre);\n    // if ($systemStateStore.graph != undefined) {\n    //   current_graph = $systemStateStore.graph as proto.Graph;\n    // } else {\n    //   current_graph = new proto.Graph();\n    // }\n    // const dynamicStyles = generateDynamicStyles(); // Generate the dynamic styles\n    cyInstance = cytoscape({\n        container: refElement,\n        style: [\n            {\n                selector: \"node\",\n                style: {\n                    width: \"label\",\n                    height: \"label\",\n                    \"font-size\": \"14px\",\n                    \"font-weight\": \"bold\",\n                    content: \"data(label)\",\n                    \"text-valign\": \"center\",\n                    \"text-wrap\": \"wrap\",\n                    \"text-max-width\": \"100px\",\n                    \"background-color\": \"#fff\",\n                    \"border-color\": \"#000\",\n                    \"border-width\": \"1px\",\n                    \"border-style\": \"solid\",\n                },\n            },\n            {\n                selector: \"edge\",\n                style: {\n                    \"curve-style\": \"bezier\",\n                    \"target-arrow-shape\": \"triangle\",\n                    \"line-color\": \"#000\",\n                    \"target-arrow-color\": \"#000\",\n                    width: \"2px\",\n                },\n            },\n            // ...dynamicStyles,\n        ],\n    });\n    cyInstance.on(\"select\", \"node\", (evt) => {\n        console.log(\"event: \", evt);\n        const selectedNode = evt.target.data();\n        console.log(\"selectedNode (this is the object stored in the graphlib graph... different node than this system): \", selectedNode);\n        $systemStateStore.local_nodes.find((node) => {\n            if (node.node_info.id == selectedNode.id) {\n                // get the selected nodes from the systemStateStore and add the node.node_info to the selected_nodes\n                let selected_list = $systemStateStore.selected_nodes;\n                selected_list.push(node.node_info);\n                $systemStateStore.selected_nodes = selected_list;\n            }\n        });\n    });\n    cyInstance.on(\"select\", \"edge\", (evt) => {\n        console.log(\"event: \", evt);\n        let edge = new proto.Edge();\n        let source = new proto.GraphNodeInfo();\n        let target = new proto.GraphNodeInfo();\n        source.id = evt.target.data().source;\n        target.id = evt.target.data().target;\n        edge.source = source;\n        edge.target = target;\n        console.log(\"selectedEdge: \", evt.target.data());\n        $systemStateStore = helper_functions.selectEdge(edge, $systemStateStore);\n    });\n    cyInstance.on(\"unselect\", \"node\", function (evt) {\n        const node = evt.target;\n        console.log(\"deselected \" + node);\n        let selected_list = $systemStateStore.selected_nodes;\n        // remove the node the graphNodeInfo from the selected_list where the id is the same as the node.id()\n        selected_list = selected_list.filter((graphNodeInfo) => {\n            return graphNodeInfo.id == node.id;\n        });\n        $systemStateStore.selected_nodes = selected_list;\n    });\n    // Listen to unselect event on any edge\n    cyInstance.on(\"unselect\", \"edge\", function (evt) {\n        const edge = evt.target;\n        console.log(\"deselected \" + edge.data().source + \" -> \" + edge.data().target);\n    });\n    // if (current_graph !== undefined) {\n    //   draw_graph(cyInstance, current_graph);\n    // }\n});\n$: {\n    // Whenever the systemState.graph changes, we will change the cytoscape graph. It might be good to check if the graph has actually changed rather than always re-draw\n    let test_graph = (_a = $systemStateStore.selected_process) === null || _a === void 0 ? void 0 : _a.node_content.process.graph;\n    // check that the test_graph is different from the current_graph\n    if (test_graph != current_graph && test_graph != undefined) {\n        current_graph = test_graph;\n        draw_graph(cyInstance, current_graph);\n    }\n}\nsetContext(\"graphSharedState\", {\n    getCyInstance: () => cyInstance,\n});\nlet refElement = null;\nlet cyInstance = null;\nfunction draw_graph(cyInstance, current_graph) {\n    // clear the cytoscape graph\n    cyInstance === null || cyInstance === void 0 ? void 0 : cyInstance.elements().remove();\n    // add the nodes to the cytoscape graph\n    let nodes = current_graph.nodes_info;\n    nodes.forEach((node_info) => {\n        if (node_info) {\n            cyInstance === null || cyInstance === void 0 ? void 0 : cyInstance.add({\n                data: {\n                    id: node_info.id,\n                    label: node_info.name,\n                },\n            });\n        }\n    });\n    // add the edges to the cytoscape graph\n    let edges = current_graph.edges;\n    edges.forEach((edge) => {\n        let source = edge.source;\n        let target = edge.target;\n        if (source && target) {\n            cyInstance === null || cyInstance === void 0 ? void 0 : cyInstance.add({\n                data: {\n                    source: source.id,\n                    target: target.id,\n                },\n            });\n        }\n    });\n    // cyInstance?.fit();\n    cyInstance === null || cyInstance === void 0 ? void 0 : cyInstance.layout({\n        name: \"dagre\",\n        fit: true,\n    }).run();\n}\n</script>\n\n<div class=\"main-content\" bind:this={refElement}>\n  {#if cyInstance}\n    <slot />\n  {/if}\n</div>\n\n<style>\n  .main-content {\n    /* transition: margin-left 0.3s ease; */\n    overflow: auto;\n    flex-grow: 1;\n  }\n</style>\n",
    "<script>\n</script>\n\n<div class=\"loading-container\">\n    <span class=\"loading-text\">Loading...</span>\n</div>\n\n<!-- CSS -->\n<style>\n    .loading-container {\n        overflow: hidden;\n        white-space: nowrap;\n    }\n    .loading-text {\n        display: inline-block;\n        animation: scrollText 1s linear infinite;\n    }\n\n    @keyframes scrollText {\n        from {\n            transform: translateX(100%);\n        }\n        to {\n            transform: translateX(-100%);\n        }\n    }\n</style>\n",
    "<script>\n  import modifyNode from \"./sidebarComponents/modifyNode.svelte\";\n  import NewNode from \"./sidebarComponents/newNode.svelte\";\n\n  import { blur, fade } from \"svelte/transition\";\n  import { onMount } from \"svelte\";\n  import ExecuteNode from \"./sidebarComponents/executeNode.svelte\";\n  import systemStateStore from \"stores/systemStateStore\";\n  import SelectedNodeInfo from \"./sidebarComponents/selectedNodeInfo.svelte\";\n\n  export let expanded = false;\n\n  onMount(() => {\n    console.log(\"Sidebar mounted\");\n  });\n\n  let sections = [\n    {\n      header: \"Create a New Node\",\n      component: NewNode,\n      open: false,\n    },\n    // {\n    //   header: \"Modify Node\",\n    //   component: modifyNode,\n    //   open: false,\n    // },\n    {\n      header: \"Execute Process\",\n      component: ExecuteNode,\n      open: false,\n    },\n    // {\n    //   header: \"Show Selected Node Info\",\n    //   component: SelectedNodeInfo,\n    //   open: false,\n    // },\n  ];\n\n  function toggleSection(clickedSection) {\n    sections = sections.map((section) => {\n      if (section === clickedSection) {\n        let open = !section.open;\n        return { ...section, open }; // just invert the `open` property of the clicked section\n      } else {\n        return section; // don't modify other sections\n      }\n    });\n  }\n</script>\n\n<div class=\"sidebar\" class:expanded>\n  {#each sections as section (section.header)}\n    <div class=\"section\" bind:this={section.ref}>\n      <div\n        class=\"section-header\"\n        on:keydown={(event) => {\n          if (event.key === \"Enter\") {\n            toggleSection(section);\n          }\n        }}\n        on:click={() => toggleSection(section)}\n      >\n        {section.header}\n      </div>\n      {#if section.open}\n        <div\n          class=\"section-content\"\n          in:fade={{ duration: 100 }}\n          out:blur={{ duration: 100, amount: 5 }}\n        >\n          <svelte:component this={section.component} />\n        </div>\n      {/if}\n    </div>\n  {/each}\n  <button on:click={() => (expanded = !expanded)}>\n    {expanded ? \"Collapse\" : \"Expand\"}\n  </button>\n</div>\n\n<style>\n  /* Sidebar */\n  .sidebar {\n    width: 200px;\n    background-color: #f0f0f0;\n    transition: width 0.1s;\n  }\n  .sidebar.expanded {\n    width: 400px;\n  }\n\n  .section {\n    margin-bottom: 25px;\n  }\n\n  .section-header {\n    font-size: 18px;\n    padding: 10px;\n    cursor: pointer;\n    background-color: #bdc3c7;\n    border: 1px solid #a5a9ab;\n    border-radius: 8px;\n    transition:\n      background-color 0.3s ease,\n      transform 0.2s ease;\n  }\n\n  .section-header:hover {\n    background-color: #a5a9ab;\n    transform: scale(1.03);\n  }\n\n  .section-content {\n    margin-top: 15px;\n    padding: 15px;\n    border: 1px solid #a5a9ab;\n    border-radius: 8px;\n    background-color: #fff;\n  }\n</style>\n",
    "<script lang=\"ts\">import \"../../generated/system_types\";\nexport let logs = []; // The array of AtomicExecutionLogs passed to this component\nfunction renderHashMap(log) {\n    let hashMap = log.response;\n    if (!(hashMap instanceof Map)) {\n        console.error(\"Expected a Map object\");\n        return \"\";\n    }\n    return Array.from(hashMap.entries())\n        .map(([key, value]) => {\n        if (value.has_number_value) {\n            return `<strong>${key}</strong>: ${value.number_value}<br>`;\n        }\n        if (value.has_string_value) {\n            return `<strong>${key}</strong>: ${value.string_value}<br>`;\n        }\n        if (value.has_string_list) {\n            // for this one we need to do some more work\n            // return each of the list items as a bullet point on a new line:\n            let listItems = value.string_list;\n            let listItemsAsBullets = listItems.values.map((item) => {\n                return `<li>${item}</li>`;\n            });\n            return `<strong>${key}</strong>: <ul>${listItemsAsBullets.join(\"\")}</ul>`;\n        }\n    })\n        .join(\", \");\n}\n</script>\n\n{#each logs as log}\n  <div class=\"log-entry\">\n    <h3>Process executed: {log.has_node_info ? log.node_info.name : \"N/A\"}</h3>\n    <p><strong>Prompt:</strong> {log.prompt}</p>\n    <div>\n      <strong>Response:</strong>\n      <div class=\"response\">\n        {@html log.response.size > 0 ? renderHashMap(log) : \"No response\"}\n      </div>\n    </div>\n  </div>\n  <hr />\n{/each}\n\n<style>\n  .log-entry {\n    margin-bottom: 1rem;\n  }\n  .response {\n    margin-top: 0.5rem;\n    background-color: #f0f0f0;\n    padding: 0.5rem;\n    border-radius: 5px;\n  }\n</style>\n",
    "<script lang=\"ts\">import { websocketStore } from \"stores/websocketStore\";\nimport { Prompt, VerbTypes, Node, GraphNodeInfo, Letter, Body, NodeTypes, NodeContent, Conditional, } from \"../../../generated/system_types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { sendEnvelope } from \"helper_functions/websocket\";\nlet system_text = \"\";\nlet prompt_text = \"\";\nlet description = \"\";\nlet name = \"\";\nlet input_variables = [];\nlet output_variables = [];\nlet new_input_variable = \"\";\nlet new_output_variable = \"\";\nfunction submitConditional() {\n    // First, validate the Handlebars template\n    if (!isValidHandlebarsTemplate(prompt_text)) {\n        alert(\"Invalid Handlebars template.\");\n        return;\n    }\n    let conditional = new Conditional();\n    let prompt = new Prompt();\n    prompt.prompt = prompt_text;\n    prompt.system = system_text;\n    conditional.prompt = prompt;\n    let node = new Node();\n    if (new_input_variable != \"\") {\n        input_variables = [...input_variables, new_input_variable];\n    }\n    // Extract and check variables from the template\n    let variable_names = extractVariableNames(prompt_text);\n    let allVariablesMatch = input_variables.every((inputVar) => variable_names.includes(inputVar));\n    let noExtraVariables = variable_names.every((templateVar) => input_variables.includes(templateVar));\n    // Combining both checks to ensure exact match\n    let exactMatch = allVariablesMatch && noExtraVariables;\n    if (new_output_variable != \"\") {\n        output_variables = [...output_variables, new_output_variable];\n    }\n    if (exactMatch) {\n        node.input_variables = input_variables;\n        node.output_variables = output_variables;\n        let node_content = new NodeContent();\n        node_content.conditional = conditional;\n        let node_info = new GraphNodeInfo();\n        node_info.name = name;\n        node_info.id = new uuidv4();\n        node_info.description = description;\n        node.node_info = node_info;\n        node.node_content = node_content;\n        node.node_type = NodeTypes.CONDITIONAL;\n        let websocket = $websocketStore.websocket;\n        let body = new Body();\n        body.node = node;\n        let letter = new Letter();\n        letter.body = body;\n        letter.verb = VerbTypes.Create;\n        sendEnvelope(websocket, [letter]);\n        reset_component();\n    }\n    else {\n        alert(\"All of the input variables do not have a definition within the template\");\n    }\n}\nfunction isValidHandlebarsTemplate(template) {\n    // A simple regex to check for basic Handlebars syntax\n    const handlebarsRegex = /\\{\\{([^}]+)\\}\\}/g;\n    return handlebarsRegex.test(template);\n}\nfunction extractVariableNames(template) {\n    const handlebarsRegex = /\\{\\{([^}]+)\\}\\}/g;\n    let match;\n    const variables = new Set();\n    while ((match = handlebarsRegex.exec(template)) !== null) {\n        // The variable is in match[1], trim it to handle spaces\n        variables.add(match[1].trim());\n    }\n    return Array.from(variables);\n}\nfunction reset_component() {\n    system_text = \"\";\n    prompt_text = \"\";\n    description = \"\";\n    name = \"\";\n    input_variables = [];\n    output_variables = [];\n    new_input_variable = \"\";\n    new_output_variable = \"\";\n}\n</script>\n\n<form on:submit|preventDefault={submitConditional}>\n  <div>\n    <div>\n      <input bind:value={name} placeholder=\"Name\" />\n\n      <input bind:value={description} placeholder=\"Description\" />\n\n      <div>\n        <h4>Input Variables</h4>\n        {#each input_variables as _inputVar, index}\n          <button\n            type=\"button\"\n            on:click={() => {\n              input_variables.splice(index, 1);\n              input_variables = input_variables;\n            }}>`Remove input var: {input_variables[index]}`</button\n          >\n        {/each}\n        <input\n          bind:value={new_input_variable}\n          placeholder=\"New Input Variable\"\n        />\n        <button\n          type=\"button\"\n          on:click={() => {\n            input_variables = [...input_variables, new_input_variable];\n            new_input_variable = \"\";\n          }}>Add</button\n        >\n      </div>\n\n      <div>\n        <h4>Output Variables</h4>\n        {#each output_variables as _outputVar, index}\n          <button\n            type=\"button\"\n            on:click={() => {\n              output_variables.splice(index, 1);\n              output_variables = output_variables;\n            }}>`Remove output Var: {output_variables[index]}`</button\n          >\n        {/each}\n        <input\n          bind:value={new_output_variable}\n          placeholder=\"New Output Variable\"\n        />\n        <button\n          type=\"button\"\n          on:click={() => {\n            output_variables = [...output_variables, new_output_variable];\n            new_output_variable = \"\";\n          }}>Add</button\n        >\n      </div>\n\n      <label for=\"prompt\" class=\"required-label\">Prompt</label>\n      <input\n        id=\"prompt\"\n        bind:value={prompt_text}\n        type=\"text\"\n        required\n        class=\"required-input\"\n      />\n\n      <label for=\"system\" class=\"required-label\">System</label>\n      <input\n        id=\"system\"\n        bind:value={system_text}\n        type=\"text\"\n        required\n        class=\"required-input\"\n      />\n\n      <button type=\"submit\">Submit</button>\n    </div>\n  </div>\n</form>\n\n<style>\n  .required-input:invalid {\n    border: 2px solid red;\n  }\n\n  .required-label::after {\n    content: \" *\";\n    color: red;\n  }\n</style>\n",
    "<script lang=\"ts\">import { onMount } from \"svelte\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { NodeTypes, GraphNodeInfo, NodesToLoop, Letter, Body, VerbTypes, } from \"generated/system_types\";\nimport systemStateStore from \"stores/systemStateStore\";\nimport { websocketStore } from \"stores/websocketStore\";\nimport { sendEnvelope } from \"helper_functions/websocket\";\nlet name = \"\";\nlet description = \"\";\nlet node_list = [];\nlet selected_node_list = [];\nlet error = \"\";\nlet max_iterations;\nlet key_list = Object.keys(NodeTypes).filter((key) => isNaN(Number(key)));\n// setup onmount:\nonMount(() => {\n    node_list = $systemStateStore.local_nodes;\n});\n$: {\n    node_list = $systemStateStore.local_nodes;\n}\nfunction isSelected(node) {\n    return selected_node_list.includes(node);\n}\nfunction toggleNodeSelect(node) {\n    if (isSelected(node)) {\n        selected_node_list = selected_node_list.filter((selected_node) => selected_node !== node);\n    }\n    else {\n        selected_node_list = [...selected_node_list, node];\n    }\n}\nfunction sendNodes() {\n    if (!name.trim() || !description.trim()) {\n        error = \"Both name and description are required!\";\n        return; // Return early to stop execution if validation fails\n    }\n    else {\n        error = \"\";\n    }\n    console.log(\"sending selected_node_list: \", selected_node_list);\n    let graph_node_info = new GraphNodeInfo();\n    graph_node_info.name = name;\n    graph_node_info.description = description;\n    graph_node_info.id = uuidv4();\n    let nodes_to_loop = new NodesToLoop();\n    nodes_to_loop.containing_node_info = graph_node_info;\n    nodes_to_loop.nodes = selected_node_list;\n    let websocket = $websocketStore.websocket;\n    let letter = new Letter();\n    let body = new Body();\n    body.nodes_to_loop = nodes_to_loop;\n    letter.body = body;\n    letter.verb = VerbTypes.Validate;\n    sendEnvelope(websocket, [letter]);\n    selected_node_list = [];\n    description = \"\";\n    name = \"\";\n}\n</script>\n\n<p>Please set a descriptive name for your loop:</p>\n<input type=\"text\" bind:value={name} />\n<p>\n    Please set a description for your loop, please talk about what purpose it\n    serves:\n</p>\n<input type=\"text\" bind:value={description} />\n\n<p>\n    Click the node buttons below to add them to the graph. Then click \"Add\n    Node(s) to see them populate on the graph.\"\n</p>\n\n<ul>\n    {#each node_list as node}\n        <li>\n            <button\n                class:selected={isSelected(node)}\n                type=\"button\"\n                on:click={() => toggleNodeSelect(node)}\n                >{key_list[node.node_type]} : {node.node_info.name}</button\n            >\n        </li>\n    {/each}\n</ul>\n\n<h3>Nodes to add:</h3>\n\n{#each selected_node_list as node}\n    <li>\n        <p>{key_list[node.node_type]} : {node.node_info.name}</p>\n    </li>\n{/each}\n\n{#if error}\n    <p class=\"error\">{error}</p>\n{/if}\n\n<label for=\"system\" class=\"required-label\">Max Iterations</label>\n<input\n    id=\"system\"\n    bind:value={max_iterations}\n    type=\"text\"\n    required\n    class=\"required-input\"\n/>\n\n<button class=\"add-button\" on:click={sendNodes}>Save Process</button>\n\n<style>\n    .error {\n        color: red;\n    }\n</style>\n",
    "<script lang=\"ts\">import { onMount } from \"svelte\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { NodeTypes, GraphNodeInfo, NodesToProcess, Letter, Body, VerbTypes, } from \"generated/system_types\";\nimport systemStateStore from \"stores/systemStateStore\";\nimport \"svelte/store\";\nimport { websocketStore } from \"stores/websocketStore\";\nimport { sendEnvelope } from \"helper_functions/websocket\";\nlet name = \"\";\nlet description = \"\";\nlet node_list = [];\nlet selected_node_list = [];\nlet error = \"\";\nlet key_list = Object.keys(NodeTypes).filter((key) => isNaN(Number(key)));\n// setup onmount:\nonMount(() => {\n    node_list = $systemStateStore.local_nodes;\n});\n$: {\n    node_list = $systemStateStore.local_nodes;\n}\nfunction isSelected(node) {\n    return selected_node_list.includes(node);\n}\nfunction toggleNodeSelect(node) {\n    if (isSelected(node)) {\n        selected_node_list = selected_node_list.filter((selected_node) => selected_node !== node);\n    }\n    else {\n        selected_node_list = [...selected_node_list, node];\n    }\n}\nfunction sendNodes() {\n    if (!name.trim() || !description.trim()) {\n        error = \"Both name and description are required!\";\n        return; // Return early to stop execution if validation fails\n    }\n    else {\n        error = \"\";\n    }\n    console.log(\"sending selected_node_list: \", selected_node_list);\n    let graph_node_info = new GraphNodeInfo();\n    graph_node_info.name = name;\n    graph_node_info.description = description;\n    graph_node_info.id = uuidv4();\n    let nodes_to_process = new NodesToProcess();\n    nodes_to_process.containing_node_info = graph_node_info;\n    nodes_to_process.nodes = selected_node_list;\n    let websocket = $websocketStore.websocket;\n    let letter = new Letter();\n    let body = new Body();\n    body.nodes_to_process = nodes_to_process;\n    letter.body = body;\n    letter.verb = VerbTypes.Validate;\n    sendEnvelope(websocket, [letter]);\n    selected_node_list = [];\n    description = \"\";\n    name = \"\";\n}\n</script>\n\n<p>Please set a descriptive name for your process:</p>\n<input type=\"text\" bind:value={name} />\n<p>\n  Please set a description for your process, please talk about what purpose it\n  serves:\n</p>\n<input type=\"text\" bind:value={description} />\n\n<p>\n  Click the node buttons below to add them to the graph. Then click \"Add Node(s)\n  to see them populate on the graph.\"\n</p>\n\n<ul>\n  {#each node_list as node}\n    <li>\n      <button\n        class:selected={isSelected(node)}\n        type=\"button\"\n        on:click={() => toggleNodeSelect(node)}\n        >{key_list[node.node_type]} : {node.node_info.name}</button\n      >\n    </li>\n  {/each}\n</ul>\n\n<h3>Nodes to add:</h3>\n\n{#each selected_node_list as node}\n  <li>\n    <p>{key_list[node.node_type]} : {node.node_info.name}</p>\n  </li>\n{/each}\n\n{#if error}\n  <p class=\"error\">{error}</p>\n{/if}\n\n<button class=\"add-button\" on:click={sendNodes}>Save Process</button>\n\n<style>\n  .error {\n    color: red;\n  }\n</style>\n",
    "<script lang=\"ts\">import { websocketStore } from \"stores/websocketStore\";\nimport { Prompt, VerbTypes, Node, GraphNodeInfo, Letter, Body, NodeTypes, NodeContent, } from \"../../../generated/system_types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { sendEnvelope } from \"helper_functions/websocket\";\nimport \"handlebars\";\nlet system_text = \"\";\nlet prompt_text = \"\";\nlet description = \"\";\nlet name = \"\";\nlet input_variables = [];\nlet output_variables = [];\nlet new_input_variable = \"\";\nlet new_output_variable = \"\";\nfunction submitPrompt() {\n    // First, validate the Handlebars template\n    if (!isValidHandlebarsTemplate(prompt_text)) {\n        alert(\"Invalid Handlebars template.\");\n        return;\n    }\n    let prompt = new Prompt();\n    prompt.prompt = prompt_text;\n    prompt.system = system_text;\n    let node = new Node();\n    if (new_input_variable != \"\") {\n        input_variables = [...input_variables, new_input_variable];\n    }\n    // Extract and check variables from the template\n    let variable_names = extractVariableNames(prompt_text);\n    let allVariablesMatch = input_variables.every((inputVar) => variable_names.includes(inputVar));\n    let noExtraVariables = variable_names.every((templateVar) => input_variables.includes(templateVar));\n    // Combining both checks to ensure exact match\n    let exactMatch = allVariablesMatch && noExtraVariables;\n    if (new_output_variable != \"\") {\n        output_variables = [...output_variables, new_output_variable];\n    }\n    if (exactMatch) {\n        node.input_variables = input_variables;\n        node.output_variables = output_variables;\n        let node_content = new NodeContent();\n        node_content.prompt = prompt;\n        let node_info = new GraphNodeInfo();\n        node_info.name = name;\n        node_info.id = new uuidv4();\n        node_info.description = description;\n        node.node_info = node_info;\n        node.node_content = node_content;\n        node.node_type = NodeTypes.PROMPT;\n        let websocket = $websocketStore.websocket;\n        let body = new Body();\n        body.node = node;\n        let letter = new Letter();\n        letter.body = body;\n        letter.verb = VerbTypes.Create;\n        sendEnvelope(websocket, [letter]);\n        reset_component();\n    }\n    else {\n        alert(\"All of the input variables do not have a definition within the template\");\n    }\n}\nfunction isValidHandlebarsTemplate(template) {\n    // A simple regex to check for basic Handlebars syntax\n    const handlebarsRegex = /\\{\\{([^}]+)\\}\\}/g;\n    return handlebarsRegex.test(template);\n}\nfunction extractVariableNames(template) {\n    const handlebarsRegex = /\\{\\{([^}]+)\\}\\}/g;\n    let match;\n    const variables = new Set();\n    while ((match = handlebarsRegex.exec(template)) !== null) {\n        // The variable is in match[1], trim it to handle spaces\n        variables.add(match[1].trim());\n    }\n    return Array.from(variables);\n}\nfunction autoExpand(event) {\n    const element = event.target;\n    element.style.height = \"auto\"; // Reset the height\n    element.style.height = element.scrollHeight + \"px\"; // Set to scroll height\n}\nfunction reset_component() {\n    system_text = \"\";\n    prompt_text = \"\";\n    description = \"\";\n    name = \"\";\n    input_variables = [];\n    output_variables = [];\n    new_input_variable = \"\";\n    new_output_variable = \"\";\n}\n</script>\n\n<form on:submit|preventDefault={submitPrompt}>\n  <div>\n    <div>\n      <input bind:value={name} placeholder=\"Name\" />\n\n      <input bind:value={description} placeholder=\"Description\" />\n\n      <div>\n        <h4>Input Variables</h4>\n        {#each input_variables as _inputVar, index}\n          <button\n            type=\"button\"\n            on:click={() => {\n              input_variables.splice(index, 1);\n              input_variables = input_variables;\n            }}>`Remove input var: {input_variables[index]}`</button\n          >\n        {/each}\n        <input\n          bind:value={new_input_variable}\n          placeholder=\"New Input Variable\"\n        />\n        <button\n          type=\"button\"\n          on:click={() => {\n            input_variables = [...input_variables, new_input_variable];\n            new_input_variable = \"\";\n          }}>Add</button\n        >\n      </div>\n\n      <div>\n        <h4>Output Variables</h4>\n        {#each output_variables as _outputVar, index}\n          <button\n            type=\"button\"\n            on:click={() => {\n              output_variables.splice(index, 1);\n              output_variables = output_variables;\n            }}>`Remove output Var: {output_variables[index]}`</button\n          >\n        {/each}\n        <input\n          bind:value={new_output_variable}\n          placeholder=\"New Output Variable\"\n        />\n        <button\n          type=\"button\"\n          on:click={() => {\n            output_variables = [...output_variables, new_output_variable];\n            new_output_variable = \"\";\n          }}>Add</button\n        >\n      </div>\n\n      <label for=\"prompt\">Prompt</label>\n      <textarea\n        id=\"prompt\"\n        bind:value={prompt_text}\n        required\n        class=\"auto-expand\"\n        on:input={autoExpand}\n      />\n\n      <label for=\"system\">System</label>\n      <textarea\n        id=\"system\"\n        bind:value={system_text}\n        required\n        class=\"auto-expand\"\n        on:input={autoExpand}\n      />\n      <button type=\"submit\">Submit</button>\n    </div>\n  </div>\n</form>\n\n<style>\n  .auto-expand {\n    overflow-y: hidden; /* Hide vertical scrollbar */\n    resize: none; /* Disable resizing */\n    min-height: 20px; /* Set a minimum height */\n    max-height: 400px; /* Set a maximum height */\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "AAoDE,6BAAe,CACb,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,KACV;ACWA,yBAAW,CACT,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,KACV,CACA,sBAAQ,CACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,GAAG,CAAE,IACP,CACA,6BAAe,CACb,gBAAgB,CAAE,KAAK,CACvB,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,IACd,CACA,6BAAc,MAAO,CACnB,gBAAgB,CAAE,SACpB,CAEA,2BAAa,CACX,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,KACd;AC2DA,2BAAc,CAEZ,QAAQ,CAAE,IAAI,CACd,SAAS,CAAE,CACb;ACtJE,iCAAmB,CACf,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MACjB,CACA,4BAAc,CACV,OAAO,CAAE,YAAY,CACrB,SAAS,CAAE,yBAAU,CAAC,EAAE,CAAC,MAAM,CAAC,QACpC,CAEA,WAAW,yBAAW,CAClB,IAAK,CACD,SAAS,CAAE,WAAW,IAAI,CAC9B,CACA,EAAG,CACC,SAAS,CAAE,WAAW,KAAK,CAC/B,CACJ;AC0DF,sBAAS,CACP,KAAK,CAAE,KAAK,CACZ,gBAAgB,CAAE,OAAO,CACzB,UAAU,CAAE,KAAK,CAAC,IACpB,CACA,QAAQ,uBAAU,CAChB,KAAK,CAAE,KACT,CAEA,sBAAS,CACP,aAAa,CAAE,IACjB,CAEA,6BAAgB,CACd,SAAS,CAAE,IAAI,CACf,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,OAAO,CACf,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CACzB,aAAa,CAAE,GAAG,CAClB,UAAU,CACR,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;AACjC,MAAM,SAAS,CAAC,IAAI,CAAC,IACnB,CAEA,6BAAe,MAAO,CACpB,gBAAgB,CAAE,OAAO,CACzB,SAAS,CAAE,MAAM,IAAI,CACvB,CAEA,8BAAiB,CACf,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CACzB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IACpB;AC1EA,wBAAW,CACT,aAAa,CAAE,IACjB,CACA,uBAAU,CACR,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,OAAO,CACzB,OAAO,CAAE,MAAM,CACf,aAAa,CAAE,GACjB;ACkHA,6BAAe,QAAS,CACtB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,GACpB,CAEA,6BAAe,OAAQ,CACrB,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,GACT;AChEE,qBAAO,CACH,KAAK,CAAE,GACX;ACXF,qBAAO,CACL,KAAK,CAAE,GACT;ACmEA,2BAAa,CACX,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,KACd"
}